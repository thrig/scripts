#!/usr/bin/env perl
#
# ow - shortcuts and directory to URL mapping

use 5.16.0;
use warnings;
use Cwd ();
use DB_File ();
use File::Basename qw(basename);
use File::HomeDir ();
use File::Spec::Functions qw(catfile rel2abs);
use Getopt::Long qw(GetOptions);
use Text::ParseWords qw(shellwords);
use URI ();

my $do_something = basename($0) eq 'wv' ? \&do_directory : \&do_shortcut;

Getopt::Long::Configure("bundling");
GetOptions(
    'always-remap|A' => \my $Flag_AlwaysRemap,
    'chdir|C:s'      => \my $Flag_Chdir,
    'directory|d'    => sub { $do_something = \&do_directory },
    'help|h|?'       => \&emit_help,
    'list|l'         => \my $Flag_ListURL,
    'open|o=s'       => \my $Flag_Method,
) or exit 65;

my $Home = File::HomeDir->my_home;

exit $do_something->();

sub do_directory {
    my $dirmap = loadmap( path_to('dirmap') );
    my $dir    = Cwd::getcwd;

    for my $ent ( sort { length $b->[0] <=> length $a->[0] } @$dirmap ) {
        my $pos = index $dir, $ent->[0];
        if ( $pos > -1 ) {
            my $frag = substr( $dir, $pos + length $ent->[0] ) || q{};

            # prevent // issues
            $frag =~ s{^/+}{} if $ent->[1] =~ m{/%[@\d]}a;

            $ent->[1] =~ s{%(\@|\d+)/}{%$1}g if $frag eq q{};

            visit( fill_in( $ent->[1], $frag ) );
        }
    }
    visit( 'file://' . $dir );
}

sub do_shortcut {
    emit_help() unless @ARGV;

    my $file = path_to('shortcuts') . '.db';
    my %shortcuts;
    tie %shortcuts, 'DB_File', $file or die "cannot tie '$file': $!\n";

    if ( @ARGV == 1 ) {
        # assume DB created with makemap(8) or equivalent; see
        #   perldoc DB_File | less -p "the NULL termination problem"
        # for details
        my $key = $ARGV[0] . "\0";
        if ( exists $shortcuts{$key} ) {
            visit( $shortcuts{$key} =~ tr/\0//dr );
        } elsif ( $ARGV[0] =~ m{^\w+(?:\+\w+)?://.} ) {
            # maybe a URL?
            visit( $ARGV[0] );
        } elsif ( $ARGV[0] =~ m{[./]} ) {
            # possibly a "foo/bar" path or "example.org" hostname?
            if ( -e $ARGV[0] ) {
                visit( 'file://' . rel2abs( $ARGV[0] ) );
            } else {
                visit( 'https://' . $ARGV[0] );
            }
        } elsif ( exists $shortcuts{"*\0"} ) {
            # wildcard shortcut; probably hard to reach given the
            # previous checks but exists to match the OmniWeb interface
            # this script was originally modelled on
            visit( fill_in( $shortcuts{"*\0"}, $ARGV[0] ) );
        } else {
            die "ow: not sure what to do with '$ARGV[0]'\n";
        }
    } else {
        my $key = shift @ARGV;

        # CommonLISP/HyperSpec: "sort" -> S -> FrontMatter/Master-Index-%1.html
        # or at least let me be lazy about not upcasing the section name
        # (this probably should be a filter or associated with the 'cli'
        # definition in the config file, somehow)
        if ( $key eq 'cli' ) {
            $ARGV[0] = uc substr $ARGV[0], 0, 1;
        }

        # shortcuts that take parameters have a trailing @ on them, but
        # user must not type that
        $key .= "@\0";

        if ( exists $shortcuts{$key} ) {
            visit( fill_in( $shortcuts{$key} =~ tr/\0//dr, @ARGV ) );
        } else {
            $key =~ tr/\0//d;
            die "ow: no such shortcut '$key'\n";
        }
    }
}

sub emit_help {
    warn <<"END_USAGE";
Usage: ow [options] [ shortcut [shortcut args ..] | file | url ]

Shortcuts or file to URL or browser mapping.

  -A     Always perform remapping (even if -o used)
  -d     Perform directory mapping instead of shortcut lookup ("wv")
  -l     Print URL instead of calling the command
  -o oo  Pass URL to the given command

END_USAGE
    exit 64;
}

sub fill_in {
    my $template_url = shift;
    # on the assumption that search sites use + to join terms...
    $template_url =~ s/\Q%@/join '+', @_/ge;
    $template_url =~ s/%(\d+)/$_[$1-1]||q{}/aeg;
    my $url = URI->new($template_url)->canonical;
    warn "notice: could not canonify URL '$template_url'\n" unless $url;
    return $url;
}

sub loadmap {
    my ($file) = @_;
    open my $fh, '<', $file or die "ow: could not open '$file': $!\n";
    my $pairs;
    while ( readline $fh ) {
        next if /^(?:#|$)/;
        my @pair = $_ =~ m/^(\S+)\s+(\S.+?)\s*$/;
        push @$pairs, \@pair if @pair == 2;
    }
    return $pairs;
}

sub path_to { catfile( $Home, '.ow', $_[0] ) }

sub visit {
    my ($url) = @_;

    if ($Flag_ListURL) {
        say $url;
        exit;
    }

    my @command;

    if ( $Flag_AlwaysRemap xor !$Flag_Method ) {
        my $remap = loadmap( path_to('remap') );
        for my $map (@$remap) {
            if ( $url =~ m{$map->[0]} ) {
                @command = shellwords( $map->[1] );
                last;
            }
        }
    }

    if ( !@command ) {
        @command = (
              defined $Flag_Method   ? shellwords($Flag_Method)
            : exists $ENV{OW_METHOD} ? shellwords( $ENV{OW_METHOD} )
            :                          'w3m'
        );
    }

    my %cmap;
    my $file = path_to('browsers') . '.db';
    tie %cmap, 'DB_File', $file or die "cannot tie '$file': $!\n";

    my $key = $command[0] . "\0";
    if ( @command == 1 and exists $cmap{$key} ) {
        @command = shellwords( $cmap{$key} =~ tr/\0//dr );
    }

    if ( defined $Flag_Chdir ) {
        $Flag_Chdir = File::HomeDir->my_home unless length $Flag_Chdir;
        chdir($Flag_Chdir) or die "ow: could not chdir '$Flag_Chdir': $!\n";
    }
    exec( @command, $url ) or die "ow: could not exec '@command': $!\n";
}
